A partir de los datos generados y los tiempos obtenidos, se concluye que los algoritmos selectionsort y sort de C++ presentados en este informe son considerablemente más eficientes en tiempos de ejecución en comparación con SelectionSort y Quicksort en datasets de gran tamaño. Esta diferencia se debe a la forma en que están implementados, priorizando la división de tareas, la optimización de operaciones y una gestión más eficiente de grandes volúmenes de datos.\\
La complejidad temporal de estos algoritmos juega un papel fundamental en su desempeño. Mientras que los algoritmos cuadráticos según \autocite{cormen2009}, como SelectionSort, tienen una complejidad de O($n^2$), lo que provoca un aumento significativo en los tiempos de ejecución con grandes volúmenes de datos, algoritmos como Quicksort, Selectionsort y el sort de C++ tienen una complejidad de O(nlog(n)), lo que reduce drásticamente el tiempo de ejecución. Esta diferencia en la tasa de crecimiento explica por qué los algoritmos más eficientes presentan tiempos de ejecución considerablemente menores, como se evidenció en los casos de prueba. En los resultados obtenidos, los algoritmos eficientes lograron tiempos de ejecución reducidos, a excepción de Quicksort, el cual mostró un uso de memoria excesivo.\\
Un aspecto curioso de los resultados es la diferencia en los tiempos de Quicksort, que mostró un mayor uso de memoria y tiempos de ejecución. Esto se debe a la mala elección del pivote, lo que genera un comportamiento cercano al peor caso O($n^2$), aumentando significativamente tanto el tiempo como la memoria utilizada.\\
Por otro lado, en la multiplicación de matrices, los resultados son contrarios a lo esperado. A pesar de que el algoritmo de Strassen tiene un orden de O($n^{2.81}$), se esperaban tiempos de ejecución menores que los de naive el cual tiene un orden de $O(n^3$). Sin embargo, las diferencias en los tiempos se deben a que Strassen realiza más operaciones que el método tradicional, ya que incluye la división de matrices en submatrices y la combinación de resultados, lo que genera una sobrecarga y reduce su eficiencia. Por lo tanto, Strassen es más efectivo para matrices mucho más grandes que las que se probaron en este informe.\\
Finalmente, al realizar el análisis de los métodos de ordenamiento de datos y multiplicación de matrices, se concluye que cada método tiene sus propias ventajas y desventajas, y su eficiencia puede variar según las circunstancias y datos medidos. Comprender estas características nos permitirá escoger el algoritmo más adecuado según las necesidades específicas para la implementación.